# Refactoring & Code Slob

## What is "Code Slob"?
"Code Slob" refers to the subtle technical debt that accumulates in codebases, especially those rapidly developed or generated by AI without strict constraints. It isn't necessarily "buggy," but it is:
-   **Verbose**: Using 10 lines where 2 would do.
-   **Complex**: Unnecessary nesting, redundant logic, or convoluted control flow.
-   **Fragile**: Hard to read and maintain.
-   **Un-Pythonic**: Ignoring language features (e.g., using `i=0; while i<len(l): ...` instead of `for x in l:`).

## Philosophy
The goal of this skill is **aggressive simplification**.

1.  **Semantics First**: We never sacrifice correctness for aesthetics. If we can't prove it behaves the same, we don't change it.
2.  **Idiomatic Python**: We strive for code that looks like it was written by a seasoned Python expert.

## Common Refactoring Targets
-   **Nested Ifs**: Convert to guard clauses.
-   **Loops**: Convert to comprehensions (list, dict, set).
-   **String Formatting**: Convert `+` or `%` to f-strings.
-   **Resource Management**: Convert `try/finally` to `with`.
-   **Type Hints**: Add strict typing to improve tooling support.

## Workflow Instructions

### 1. Receive Input
You will be provided with a **target directory** path. This directory contains one or more subdirectories (jobs), each representing a refactoring case.
*   *Structure*: `target_dir/job_name/original.py`

### 2. Process Jobs
For **each subdirectory** in the target directory:
1.  **Read**: Read the content of `original.py`.
2.  **Infer Types**: If the functions in `original.py` lack type hints, infer the intended types for their arguments based on usage, docstrings, or logic. Save these to `type_hints.json` in the same subdirectory.
    *   *Format*: `{"function_name": ["type1", "type2", ...]}`.
    *   *Example `type_hints.json`*:
        ```json
        {
          "compute_average": ["list[float]"],
          "format_user_greeting": ["str", "int"]
        }
        ```
3.  **Load Persona**: Refer to `prompts.md` for refactoring rules.
4.  **Refactor**: Internally generate the cleaner, idiomatic version of the code.
    *   *Constraint*: Must be drop-in compatible (same signatures).
    *   *Constraint*: Use `type hints`.
5.  **Save**: Write the refactored code to a new file named `refactored.py` **inside the same subdirectory**.
    *   *Result*: `target_dir/job_name/refactored.py` exists next to `original.py`.

### 3. Report
Inform the user that the refactoring candidates have been generated.

## Resources
- **Prompts**: `prompts.md`
