# Refactoring & Code Slob

## What is "Code Slob"?
"Code Slob" refers to the subtle technical debt that accumulates in codebases, especially those rapidly developed or generated by AI without strict constraints. It isn't necessarily "buggy," but it is:
-   **Verbose**: Using 10 lines where 2 would do.
-   **Complex**: Unnecessary nesting, redundant logic, or convoluted control flow.
-   **Fragile**: Hard to read and maintain.
-   **Un-Pythonic**: Ignoring language features (e.g., using `i=0; while i<len(l): ...` instead of `for x in l:`).

## Philosophy
The goal of this skill is **aggressive simplification**.

1.  **Semantics First**: We never sacrifice correctness for aesthetics. If we can't prove it behaves the same, we don't change it.
2.  **Idiomatic Python**: We strive for code that looks like it was written by a seasoned Python expert.

## Common Refactoring Targets
-   **Nested Ifs**: Convert to guard clauses.
-   **Loops**: Convert to comprehensions (list, dict, set).
-   **String Formatting**: Convert `+` or `%` to f-strings.
-   **Resource Management**: Convert `try/finally` to `with`.
-   **Type Hints**: Add strict typing to improve tooling support.

## Workflow Instructions

### 1. Discovery & Batch Reading
1.  **List**: List the contents of the **.code-slob-tmp** directory to identify all job subdirectories.
2.  **Batch Read**: Read the `original.py` file in **all** subdirectories using parallel tool calls. Do *not* read them one by one in separate turns.
    *   *Constraint*: **Do not** read files outside the `.code-slob-tmp` (e.g., do not read `inventory.py` or `utils.py` in the root). Trust that `original.py` contains the code to be refactored.
    *   *Efficiency*: Do NOT re-read the `original.py` files after you have extracted them or read them once.

### 2. Process Jobs
For **each subdirectory** (job):
1.  **Analyze**: Examine the `original.py` content.
2.  **Infer Types & Constraints**: Infer argument types based on usage/docstrings. Save to `type_hints.json` in the subdirectory.
    *   **Proactive Constraints**: If a function is recursive (e.g., Fibonacci), uses deeply nested loops, or performs O(N^2) operations on large lists, you MUST proactively add input range constraints (e.g., `int(0, 15)`) to avoid verification timeouts.
    *   *External Dependencies*: If the code requires external packages not already present in the script's environment (e.g., `requests`, `pandas`, `pydantic`), add them to a `"modules"` list in `type_hints.json`. The orchestrator will automatically include them using `uv run --with`.
    *   *Format*:
        ```json
        {
          "functions": {
            "function_name": ["type1", "type2", ...],
            "function_name_2": ["int", "list[float]"]
          },
          "modules": ["pkg1", "pkg2"]
        }
        ```
    *   *Example `type_hints.json`*:
        ```json
        {
          "functions": {
            "compute_average": ["list[float]"]
          },
          "modules": ["numpy"]
        }
        ```
3.  **Load Persona**: Refer to `references/prompts.md` for refactoring rules.
4.  **Refactor**: Internally generate the cleaner, idiomatic version of the code.
    *   *Constraint*: Must be drop-in compatible (same signatures).
    *   *Constraint*: Follow ALL rules in `references/prompts.md`, especially regarding floating-point precision and boundary checks.
    *   *Constraint*: Use `type hints`.
5.  **Save**: Write the refactored code to a new file named `refactored.py` **inside the same subdirectory**.
    *   *Result*: `.code-slob-tmp/job_name/refactored.py` exists next to `original.py`.
    *   *Tooling*: Use the `write_file` tool. Do not use shell redirects.

### 3. Verification & Iteration
AFTER generating the refactored code for all jobs:

1.  **Verify**: Run the verification orchestrator to ensure the refactored code maintains the same behavior as the original.
    *   **Command**: `uv run scripts/orchestrator.py .code-slob-tmp`
2.  **Iterate**: Check the output of the orchestrator.
    *   If it says `[PASS]`: You are done with that job.
    *   If it says `[FAIL]`: Analyze the error logs provided in the output. Modify `refactored.py` to fix the issues. Rerun the orchestrator.
    *   **Retry Limit**: You have a maximum of 3 attempts to fix and verify. If it fails after 3 attempts, stop and report the failure.

### 4. Apply
1.  **Check Status**: Review the orchestrator output for each function.
    *   **PASS**: Proceed to patch.
    *   **FAIL** or **SKIP**: Do **NOT** apply refactorings for this function. Leave the original code as-is.
2.  **Patch**: Apply the refactored code to the original source files for passing functions.
    *   **Full File Replacement**: If `refactored.py` contains the *complete* file content (including imports, all functions, etc.), you may overwrite the target file directly.
    *   **Partial Merge**: If `original.py` (and thus `refactored.py`) contained only *subsets* of the code (e.g., specific functions), you **MUST** read the target file (e.g., `inventory.py`) and carefully replace *only* the refactored functions, preserving surrounding code, comments, and global variables.
    *   *Constraint*: Only modify the file if verification PASSED.
3.  **Report**: Inform the user that the code has been successfully refactored and verified.

## Constraints & Safety
*   **Do NOT modify the orchestrator**: Never attempt to edit `scripts/orchestrator.py` or any files in the `scripts` directory. If the orchestrator fails (e.g., syntax error, missing dependency), report it to the user immediately.
*   **Verification-First Policy**: Never apply refactorings for any functions that result in a `[FAIL]` or `[SKIP]` status from the verifier. Correctness and verification are paramount.
*   **Do NOT modify original files BEFORE verification**: Only overwrite them in the final "Apply" step.
*   **Scope**: Work primarily within `.code-slob-tmp`.
